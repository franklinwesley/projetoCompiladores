/*
 * generated by Xtext
 */
package org.xtext.validation

import org.eclipse.xtext.validation.Check
import org.xtext.simpleJava.compilation_unit
import org.xtext.simpleJava.type_declaration
import org.eclipse.emf.common.util.EList
import java.util.List
import java.util.ArrayList
import org.xtext.simpleJava.while_statement
import org.xtext.simpleJava.variable_declaration
import org.xtext.simpleJava.variable_declarator

//import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SimpleJavaValidator extends AbstractSimpleJavaValidator {

	//TODO ve se eh necessario mesmo um map
	private final List<Tipo> tipos = new ArrayList<Tipo>();
	private final List<Variavel> variaveis = new ArrayList<Variavel>();

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def runChecks (compilation_unit comp) {
		//ver esse get(0) para ser get(i)
		checkTypeDeclaration(comp.declaracao);
		checkVariableDeclaration(comp.declaracao);
//		checkVariableInitializer(comp, comp.declaracao);
		checkInterativeWhile(comp.declaracao);
//		checkExpression();
	}
	
	def checkInterativeWhile(EList<type_declaration> list) {
		for (type_declaration declaracoes : list) {
			checkWhile(declaracoes.declaracaoClasse.corpoClasse.declaracaoMetodo.blocoMetodo.corpo.corpoWhile);	
		} 
	}
	
	def checkVariableDeclaration(EList<type_declaration> list) {
		for (type_declaration declaracoes : list) {
			checkDeclaracaoVariavel(declaracoes.declaracaoClasse.corpoClasse.declaracaoVariavel);
			checkDeclaracaoVariavel(declaracoes.declaracaoInterface.corpoInterface.declaracaoVariavel);	
		}
	}
	
	def checkDeclaracaoVariavel(variable_declaration declaration) {
		//TODO ver se esse new tipo pega
		var tipo = new Tipo(String.valueOf(declaration.tipoVariavel.tipo));
		if (!tipos.contains(tipo)) {
			//error tipo naum existe
		} else {
			//add variavel
			var vars = declaration.declaracaoVariaveis;
			for (variable_declarator variable: vars) {	
				var variavel = new Variavel(variable.nomeVariavel, tipo);
				if (!variaveis.contains(variavel)) {
					variaveis.add(variavel);
				} else {
					//erro variavel ja existe
				}
			}
		}
	}
	
	
	def checkWhile(while_statement statement) {
		var logico = statement.expressaoWhile.tipoLogical;
		var operador = statement.expressaoWhile.expressoes.opedador
		if (logico == null && operador != ">" && operador != "<" && operador != ">=" 
			&& operador != "<=" && operador != "==" && operador != "!=" && operador != ">>=" && operador != "<<" 
			&& operador != ">>" && operador != ">>>") {
			//erro expressao invalida
		} else {
			if (statement.blocoWhile.bloco.corpo.corpoWhile != null) {
				checkWhile(statement.blocoWhile.bloco.corpo.corpoWhile);
			}
		}
	}
	
	
//	def checkVariableInitializer(compilation_unit unit, EList<type_declaration> list) {
//		var variable_declaration = list.get(0).declaracaoClasse.corpoClasse.declaracaoVariavel.declaracaoVariaveis.get(0);
//		var variavel = new Variavel(variable_declaration.nomeVariavel, list.get(0).declaracaoClasse.corpoClasse.declaracaoVariavel.tipo);
//		if (variaveis.containsValue(variavel)) {
//			//error ja tem a variavel
//		} else {
//			variaveis.put(unit,variavel);
//			//checkar o tipo se esta certo
//		}
//	}
	
	def checkTypeDeclaration(EList<type_declaration> list) {
		var type_declaration = list.get(0);
		if (type_declaration.declaracaoClasse != null) {
			//salvar o tipo
			addType(type_declaration.declaracaoClasse.nomeClasse);
		} else {
			//salva o tipo
			addType(type_declaration.declaracaoInterface.nomeInterface);
		}
	}
	
	def addType(String tipo) {
		//adicionar na tabela de simbolos caso naum exista
		var t = new Tipo (tipo);
		if (!tipos.contains(t)) {
			tipos.add(t);
		}
	}
}