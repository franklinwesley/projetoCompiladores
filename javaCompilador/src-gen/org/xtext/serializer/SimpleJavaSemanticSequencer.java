/*
 * generated by Xtext
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.services.SimpleJavaGrammarAccess;
import org.xtext.simpleJava.MODIFIER;
import org.xtext.simpleJava.Model;
import org.xtext.simpleJava.SimpleJavaPackage;
import org.xtext.simpleJava.arglist;
import org.xtext.simpleJava.aux;
import org.xtext.simpleJava.bit_expression;
import org.xtext.simpleJava.class_declaration;
import org.xtext.simpleJava.compilation_unit;
import org.xtext.simpleJava.constructor_declaration;
import org.xtext.simpleJava.creating_aux;
import org.xtext.simpleJava.creating_expression;
import org.xtext.simpleJava.do_statement;
import org.xtext.simpleJava.exp_aux;
import org.xtext.simpleJava.expression;
import org.xtext.simpleJava.expression_aux;
import org.xtext.simpleJava.field_declaration;
import org.xtext.simpleJava.for_statement;
import org.xtext.simpleJava.if_statement;
import org.xtext.simpleJava.import_statement;
import org.xtext.simpleJava.interface_declaration;
import org.xtext.simpleJava.literal_expression;
import org.xtext.simpleJava.logical_expression;
import org.xtext.simpleJava.mais_aux;
import org.xtext.simpleJava.method_declaration;
import org.xtext.simpleJava.name;
import org.xtext.simpleJava.numeric_expression;
import org.xtext.simpleJava.package_name_aux;
import org.xtext.simpleJava.package_statement;
import org.xtext.simpleJava.parameter;
import org.xtext.simpleJava.parameter_list;
import org.xtext.simpleJava.statement;
import org.xtext.simpleJava.statement_block;
import org.xtext.simpleJava.static_initializer;
import org.xtext.simpleJava.switch_statement;
import org.xtext.simpleJava.try_statement;
import org.xtext.simpleJava.type;
import org.xtext.simpleJava.type_declaration;
import org.xtext.simpleJava.type_specifier;
import org.xtext.simpleJava.variable_declaration;
import org.xtext.simpleJava.variable_declarator;
import org.xtext.simpleJava.variable_initializer;
import org.xtext.simpleJava.while_statement;

@SuppressWarnings("all")
public class SimpleJavaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SimpleJavaGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == SimpleJavaPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case SimpleJavaPackage.MODIFIER:
				sequence_MODIFIER(context, (MODIFIER) semanticObject); 
				return; 
			case SimpleJavaPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SimpleJavaPackage.ARGLIST:
				sequence_arglist(context, (arglist) semanticObject); 
				return; 
			case SimpleJavaPackage.AUX:
				if(context == grammarAccess.getAuxRule() ||
				   context == grammarAccess.getCreating_auxRule()) {
					sequence_aux(context, (aux) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpression_auxRule()) {
					sequence_aux_expression_aux(context, (aux) semanticObject); 
					return; 
				}
				else break;
			case SimpleJavaPackage.BIT_EXPRESSION:
				sequence_bit_expression(context, (bit_expression) semanticObject); 
				return; 
			case SimpleJavaPackage.CLASS_DECLARATION:
				sequence_class_declaration(context, (class_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.COMPILATION_UNIT:
				sequence_compilation_unit(context, (compilation_unit) semanticObject); 
				return; 
			case SimpleJavaPackage.CONSTRUCTOR_DECLARATION:
				sequence_constructor_declaration(context, (constructor_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.CREATING_AUX:
				sequence_creating_aux(context, (creating_aux) semanticObject); 
				return; 
			case SimpleJavaPackage.CREATING_EXPRESSION:
				sequence_creating_expression(context, (creating_expression) semanticObject); 
				return; 
			case SimpleJavaPackage.DO_STATEMENT:
				sequence_do_statement(context, (do_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.EXP_AUX:
				if(context == grammarAccess.getExp_auxRule()) {
					sequence_exp_aux(context, (exp_aux) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpressionRule()) {
					sequence_exp_aux_expression(context, (exp_aux) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpression_auxRule()) {
					sequence_exp_aux_expression_expression_aux(context, (exp_aux) semanticObject); 
					return; 
				}
				else break;
			case SimpleJavaPackage.EXPRESSION:
				if(context == grammarAccess.getExpressionRule()) {
					sequence_expression(context, (expression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpression_auxRule()) {
					sequence_expression_expression_aux(context, (expression) semanticObject); 
					return; 
				}
				else break;
			case SimpleJavaPackage.EXPRESSION_AUX:
				sequence_expression_aux(context, (expression_aux) semanticObject); 
				return; 
			case SimpleJavaPackage.FIELD_DECLARATION:
				sequence_field_declaration(context, (field_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.FOR_STATEMENT:
				sequence_for_statement(context, (for_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.IF_STATEMENT:
				sequence_if_statement(context, (if_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.IMPORT_STATEMENT:
				sequence_import_statement(context, (import_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.INTERFACE_DECLARATION:
				sequence_interface_declaration(context, (interface_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.LITERAL_EXPRESSION:
				sequence_literal_expression(context, (literal_expression) semanticObject); 
				return; 
			case SimpleJavaPackage.LOGICAL_EXPRESSION:
				sequence_logical_expression(context, (logical_expression) semanticObject); 
				return; 
			case SimpleJavaPackage.MAIS_AUX:
				sequence_mais_aux(context, (mais_aux) semanticObject); 
				return; 
			case SimpleJavaPackage.METHOD_DECLARATION:
				sequence_method_declaration(context, (method_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.NAME:
				if(context == grammarAccess.getExpression_auxRule()) {
					sequence_expression_aux_name(context, (name) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getNameRule()) {
					sequence_name(context, (name) semanticObject); 
					return; 
				}
				else break;
			case SimpleJavaPackage.NUMERIC_EXPRESSION:
				sequence_numeric_expression(context, (numeric_expression) semanticObject); 
				return; 
			case SimpleJavaPackage.PACKAGE_NAME_AUX:
				sequence_package_name_aux(context, (package_name_aux) semanticObject); 
				return; 
			case SimpleJavaPackage.PACKAGE_STATEMENT:
				sequence_package_statement(context, (package_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.PARAMETER:
				sequence_parameter(context, (parameter) semanticObject); 
				return; 
			case SimpleJavaPackage.PARAMETER_LIST:
				sequence_parameter_list(context, (parameter_list) semanticObject); 
				return; 
			case SimpleJavaPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case SimpleJavaPackage.STATEMENT_BLOCK:
				sequence_statement_block(context, (statement_block) semanticObject); 
				return; 
			case SimpleJavaPackage.STATIC_INITIALIZER:
				sequence_static_initializer(context, (static_initializer) semanticObject); 
				return; 
			case SimpleJavaPackage.SWITCH_STATEMENT:
				sequence_switch_statement(context, (switch_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.TRY_STATEMENT:
				sequence_try_statement(context, (try_statement) semanticObject); 
				return; 
			case SimpleJavaPackage.TYPE:
				if(context == grammarAccess.getExpression_auxRule()) {
					sequence_exp_aux_expression_expression_aux_type(context, (type) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExpressionRule()) {
					sequence_exp_aux_expression_type(context, (type) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getExp_auxRule()) {
					sequence_exp_aux_type(context, (type) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getTypeRule()) {
					sequence_type(context, (type) semanticObject); 
					return; 
				}
				else break;
			case SimpleJavaPackage.TYPE_DECLARATION:
				sequence_type_declaration(context, (type_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.TYPE_SPECIFIER:
				sequence_type_specifier(context, (type_specifier) semanticObject); 
				return; 
			case SimpleJavaPackage.VARIABLE_DECLARATION:
				sequence_variable_declaration(context, (variable_declaration) semanticObject); 
				return; 
			case SimpleJavaPackage.VARIABLE_DECLARATOR:
				sequence_variable_declarator(context, (variable_declarator) semanticObject); 
				return; 
			case SimpleJavaPackage.VARIABLE_INITIALIZER:
				sequence_variable_initializer(context, (variable_initializer) semanticObject); 
				return; 
			case SimpleJavaPackage.WHILE_STATEMENT:
				sequence_while_statement(context, (while_statement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         modificador='public' | 
	 *         modificador='private' | 
	 *         modificador='protected' | 
	 *         modificador='static' | 
	 *         modificador='final' | 
	 *         modificador='native' | 
	 *         modificador='synchronized' | 
	 *         modificador='abstract' | 
	 *         modificador='threadsafe' | 
	 *         modificador='transient'
	 *     )
	 */
	protected void sequence_MODIFIER(EObject context, MODIFIER semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     comp+=compilation_unit
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (expressoesArgumentos+=expression expressoesArgumentos+=expression*) | 
	 *         (tipoParametro+=type nomeParametro+=IDENTIFIER (tipoParametro+=type nomeParametro+=IDENTIFIER)*)
	 *     )
	 */
	protected void sequence_arglist(EObject context, arglist semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     espressao=expression
	 */
	protected void sequence_aux(EObject context, aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (espressao=expression expressoes=expression_aux)
	 */
	protected void sequence_aux_expression_aux(EObject context, aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operador='~' expressao=expression)
	 */
	protected void sequence_bit_expression(EObject context, bit_expression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.BIT_EXPRESSION__OPERADOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.BIT_EXPRESSION__OPERADOR));
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.BIT_EXPRESSION__EXPRESSAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.BIT_EXPRESSION__EXPRESSAO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBit_expressionAccess().getOperadorTildeKeyword_0_0(), semanticObject.getOperador());
		feeder.accept(grammarAccess.getBit_expressionAccess().getExpressaoExpressionParserRuleCall_1_0(), semanticObject.getExpressao());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         modificadores+=MODIFIER* 
	 *         nomeClasse=IDENTIFIER 
	 *         superclasse=name? 
	 *         (implementosClasse+=name implementosClasse+=name*)? 
	 *         (corpoClasse=field_declaration | declaracaoClasse=class_declaration)*
	 *     )
	 */
	protected void sequence_class_declaration(EObject context, class_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pacote=package_statement? importes+=import_statement* declaracao+=type_declaration*)
	 */
	protected void sequence_compilation_unit(EObject context, compilation_unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (modificador=MODIFIER* tipo=type? nomeContrutor=IDENTIFIER parametrosContrutor=parameter_list? blocoConstrutor=statement_block)
	 */
	protected void sequence_constructor_declaration(EObject context, constructor_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     argumentos=arglist?
	 */
	protected void sequence_creating_aux(EObject context, creating_aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (((novoObjeto=name parametros=creating_aux) | (tipoObjeto=type_specifier parametros=aux?) | expressaoNew=expression) novo=new*)
	 */
	protected void sequence_creating_expression(EObject context, creating_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (blocoDo=statement expressaoWhile=expression)
	 */
	protected void sequence_do_statement(EObject context, do_statement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.DO_STATEMENT__BLOCO_DO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.DO_STATEMENT__BLOCO_DO));
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.DO_STATEMENT__EXPRESSAO_WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.DO_STATEMENT__EXPRESSAO_WHILE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDo_statementAccess().getBlocoDoStatementParserRuleCall_1_0(), semanticObject.getBlocoDo());
		feeder.accept(grammarAccess.getDo_statementAccess().getExpressaoWhileExpressionParserRuleCall_4_0(), semanticObject.getExpressaoWhile());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expressao=expression
	 */
	protected void sequence_exp_aux(EObject context, exp_aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressao=expression expressoes=expression_aux)
	 */
	protected void sequence_exp_aux_expression(EObject context, exp_aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressao=expression expressoes=expression_aux expressoes=expression_aux)
	 */
	protected void sequence_exp_aux_expression_expression_aux(EObject context, exp_aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((tipo=type_specifier | tipo=name) expressao=expression expressoes=expression_aux expressoes=expression_aux)
	 */
	protected void sequence_exp_aux_expression_expression_aux_type(EObject context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((tipo=type_specifier | tipo=name) expressao=expression expressoes=expression_aux)
	 */
	protected void sequence_exp_aux_expression_type(EObject context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((tipo=type_specifier | tipo=name) expressao=expression)
	 */
	protected void sequence_exp_aux_type(EObject context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             parametros=arglist? | 
	 *             exp=expression | 
	 *             (op=mais_aux exp=expression) | 
	 *             operador='++' | 
	 *             operador='--' | 
	 *             (
	 *                 (
	 *                     op=mais_aux | 
	 *                     operador='-' | 
	 *                     operador='-=' | 
	 *                     operador='*' | 
	 *                     operador='*=' | 
	 *                     operador='/' | 
	 *                     operador='/=' | 
	 *                     operador='%' | 
	 *                     operador='%='
	 *                 ) 
	 *                 exp=expression
	 *             ) | 
	 *             (
	 *                 (
	 *                     operador='>' | 
	 *                     operador='<' | 
	 *                     operador='>=' | 
	 *                     operador='<=' | 
	 *                     operador='==' | 
	 *                     operador='!='
	 *                 ) 
	 *                 exp=expression
	 *             ) | 
	 *             ((operador='>>=' | operador='<<' | operador='>>' | operador='>>>') exp=expression)
	 *         ) 
	 *         expressoes=expression_aux
	 *     )?
	 */
	protected void sequence_expression_aux(EObject context, expression_aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nome=IDENTIFIER pacote=package_name_aux expressoes=expression_aux)
	 */
	protected void sequence_expression_aux_name(EObject context, name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             tipoLogical=logical_expression | 
	 *             tipoNumeric=numeric_expression | 
	 *             tipoBit=bit_expression | 
	 *             new=creating_expression | 
	 *             literal=literal_expression | 
	 *             identificador=IDENTIFIER
	 *         )? 
	 *         expressoes=expression_aux
	 *     )
	 */
	protected void sequence_expression(EObject context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             tipoLogical=logical_expression | 
	 *             tipoNumeric=numeric_expression | 
	 *             tipoBit=bit_expression | 
	 *             new=creating_expression | 
	 *             literal=literal_expression | 
	 *             identificador=IDENTIFIER
	 *         )? 
	 *         expressoes=expression_aux 
	 *         expressoes=expression_aux
	 *     )
	 */
	protected void sequence_expression_expression_aux(EObject context, expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         declaracaoMetodo=method_declaration | 
	 *         declaracaoConstrutor=constructor_declaration | 
	 *         declaracaoVariavel=variable_declaration | 
	 *         estatico=static_initializer
	 *     )?
	 */
	protected void sequence_field_declaration(EObject context, field_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (declaracaoVariavel=variable_declaration | expressaoDeclaracao=expression)? 
	 *         expressaoFor=expression? 
	 *         expressaoIncremento=expression? 
	 *         blocoFor=statement
	 *     )
	 */
	protected void sequence_for_statement(EObject context, for_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (espressaoIf=expression blcoIf=statement blocoElse=statement?)
	 */
	protected void sequence_if_statement(EObject context, if_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     nomeImporte=name
	 */
	protected void sequence_import_statement(EObject context, import_statement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.IMPORT_STATEMENT__NOME_IMPORTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.IMPORT_STATEMENT__NOME_IMPORTE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImport_statementAccess().getNomeImporteNameParserRuleCall_1_0(), semanticObject.getNomeImporte());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (modificadores+=MODIFIER* nomeInterface=IDENTIFIER (superinterfaces+=name superinterfaces+=name*)? corpoInterface=field_declaration*)
	 */
	protected void sequence_interface_declaration(EObject context, interface_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (decimal=DECIMAL_DIGITS | inteiro=INTEGER_LITERAL | float=FLOAT_LITERAL | string=STRING)
	 */
	protected void sequence_literal_expression(EObject context, literal_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((operador='!' expressao=expression) | operador='true' | operador='false')
	 */
	protected void sequence_logical_expression(EObject context, logical_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (operador='+' | operador='+=')
	 */
	protected void sequence_mais_aux(EObject context, mais_aux semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (modificadorMetodo=MODIFIER* tipoRetorno=type nomeMetodo=IDENTIFIER parametrosMetodo=parameter_list? blocoMetodo=statement_block?)
	 */
	protected void sequence_method_declaration(EObject context, method_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nome=IDENTIFIER pacote=package_name_aux)
	 */
	protected void sequence_name(EObject context, name semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((operador='-' | operador='++' | operador='--') expressao=expression)
	 */
	protected void sequence_numeric_expression(EObject context, numeric_expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nomePacote=IDENTIFIER pacote=package_name_aux)*
	 */
	protected void sequence_package_name_aux(EObject context, package_name_aux semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.PACKAGE_NAME_AUX__NOME_PACOTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.PACKAGE_NAME_AUX__NOME_PACOTE));
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.PACKAGE_NAME_AUX__PACOTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.PACKAGE_NAME_AUX__PACOTE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPackage_name_auxAccess().getNomePacoteIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getNomePacote());
		feeder.accept(grammarAccess.getPackage_name_auxAccess().getPacotePackage_name_auxParserRuleCall_2_0(), semanticObject.getPacote());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     noomePacote=name
	 */
	protected void sequence_package_statement(EObject context, package_statement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.PACKAGE_STATEMENT__NOOME_PACOTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.PACKAGE_STATEMENT__NOOME_PACOTE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPackage_statementAccess().getNoomePacoteNameParserRuleCall_1_0(), semanticObject.getNoomePacote());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (parametros+=parameter parametros+=parameter*)
	 */
	protected void sequence_parameter_list(EObject context, parameter_list semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (tipoParametro=type nomeParametro=IDENTIFIER)
	 */
	protected void sequence_parameter(EObject context, parameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.PARAMETER__TIPO_PARAMETRO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.PARAMETER__TIPO_PARAMETRO));
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.PARAMETER__NOME_PARAMETRO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.PARAMETER__NOME_PARAMETRO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParameterAccess().getTipoParametroTypeParserRuleCall_0_0(), semanticObject.getTipoParametro());
		feeder.accept(grammarAccess.getParameterAccess().getNomeParametroIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getNomeParametro());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     corpo=statement*
	 */
	protected void sequence_statement_block(EObject context, statement_block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         declaracaoVariavel=variable_declaration | 
	 *         expressao=expression | 
	 *         bloco=statement_block | 
	 *         corpoIf=if_statement | 
	 *         corpoDoWhile=do_statement | 
	 *         corpoWhile=while_statement | 
	 *         corpoFor=for_statement | 
	 *         corpoTryCatch=try_statement | 
	 *         corpoSwitchCase=switch_statement | 
	 *         (expressaoSynchronized=expression corpoSynchronize=statement) | 
	 *         return=expression? | 
	 *         exececao=expression | 
	 *         break=IDENTIFIER? | 
	 *         continue=IDENTIFIER?
	 *     )?
	 */
	protected void sequence_statement(EObject context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     blocoEstatico=statement_block
	 */
	protected void sequence_static_initializer(EObject context, static_initializer semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.STATIC_INITIALIZER__BLOCO_ESTATICO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.STATIC_INITIALIZER__BLOCO_ESTATICO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStatic_initializerAccess().getBlocoEstaticoStatement_blockParserRuleCall_1_0(), semanticObject.getBlocoEstatico());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (expressaoSwitch=expression (expressaoCases+=expression | blocoSwitch=statement)*)
	 */
	protected void sequence_switch_statement(EObject context, switch_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (blocoTry=statement_block (parametroCatch=parameter blocoCatch=statement_block)* blocoFinally=statement_block?)
	 */
	protected void sequence_try_statement(EObject context, try_statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (declaracaoClasse=class_declaration | declaracaoInterface=interface_declaration)
	 */
	protected void sequence_type_declaration(EObject context, type_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nome='boolean' | 
	 *         nome='byte' | 
	 *         nome='char' | 
	 *         nome='short' | 
	 *         nome='int' | 
	 *         nome='float' | 
	 *         nome='long' | 
	 *         nome='double'
	 *     )
	 */
	protected void sequence_type_specifier(EObject context, type_specifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (tipo=type_specifier | tipo=name)
	 */
	protected void sequence_type(EObject context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         modificador=MODIFIER* 
	 *         tipoVariavel=type? 
	 *         declaracaoVariaveis+=variable_declarator 
	 *         declaracaoVariaveis+=variable_declarator* 
	 *         blocoVariavel=statement_block?
	 *     )
	 */
	protected void sequence_variable_declaration(EObject context, variable_declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (nomeVariavel=IDENTIFIER valorVariavel=variable_initializer?)?
	 */
	protected void sequence_variable_declarator(EObject context, variable_declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressaoVariavel=expression | (valorVariaveis+=variable_initializer valorVariaveis+=variable_initializer*)?)
	 */
	protected void sequence_variable_initializer(EObject context, variable_initializer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expressaoWhile=expression blocoWhile=statement)
	 */
	protected void sequence_while_statement(EObject context, while_statement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.WHILE_STATEMENT__EXPRESSAO_WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.WHILE_STATEMENT__EXPRESSAO_WHILE));
			if(transientValues.isValueTransient(semanticObject, SimpleJavaPackage.Literals.WHILE_STATEMENT__BLOCO_WHILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SimpleJavaPackage.Literals.WHILE_STATEMENT__BLOCO_WHILE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhile_statementAccess().getExpressaoWhileExpressionParserRuleCall_2_0(), semanticObject.getExpressaoWhile());
		feeder.accept(grammarAccess.getWhile_statementAccess().getBlocoWhileStatementParserRuleCall_4_0(), semanticObject.getBlocoWhile());
		feeder.finish();
	}
}
